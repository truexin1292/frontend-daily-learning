<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>面向对象类</title>
</head>
<body>
<script>
    /**
     * 类的声明
     */
    function Animal() {
        this.name = 'name';
    }

    /**
     * ES6中class的声明
     */
    class Animal2 {
        constructor() {
            this.name = 'name';
        }
    }

    /**
     * 实例一个对象：实例化
     */
    //注意：没有参数的时候一样 ：new Animal() === new Animal
    console.log(new Animal());
    console.log(new Animal2());


    /**
     * 借助构造函数实现继承
     */
    function Parent1() {
        this.name = 'parent1';
    }

    Parent1.prototype.say = function () {

    }

    function Child1() {
        Parent1.call(this); // apply 与 call 一样，改变函数的执行上下文；修改this指向
        // 修改父级的this，指向儿子的this；（继承的关键）；但是Child1并没有继承Parent1原型链上的属性和方法；
        // 部分继承：必须父类的属性和方法都在原构造函数里面才行，若父类的原型链上面还是属性和方法，则无法拿到；
        this.type = 'child1';
    }

    console.log(new Child1);
    console.log(new Child1().say()); // 会报错

    /**
     * 借助原型链实现继承
     * */
    function Parent2() {
        this.name = 'parent2';
        this.play = [1, 2, 3]; // 引用类型；
    }

    function Child2() {
        this.type = 'child2';
    }

    Child2.prototype = new Parent2();

    var s1 = new Child2();
    var s2 = new Child2();

    s1.play.push(4); // 引用类型；修改父类的引用类型play；
    console.log('--log--:', s1, s2); // [1,2,3,4] [1,2,3,4]

    /**
     * 组合方式
     * */
    function Parent3() {
        this.name = 'parent3';
        this.play = [1, 2, 3];
    }

    function Child3() {
        Parent3.call(this);
        this.type = 'child3';
    }

    Child3.prototype = new Parent3();
    var s3 = new Child3();
    var s4 = new Child3();
    s3.play.push(4);
    console.log('--log--:', s3, s4); // [1,2,3,4] [1,2,3]

    /**
     * 组合继承的优化1
     * */
    function Parent4() {
        this.name = 'parent4';
        this.play = [1, 2, 3];
    }

    function Child4() {
        Parent4.call(this);
        this.type = 'child4';
    }

    Child4.prototype = Parent4.prototype; // constructor都是指向父类直接的实例

    var s5 = new Child4();
    var s6 = new Child4();
    s5.play.push(4); // [1,2,3,4] [1,2,3]
    console.log(s5 instanceof Child5);
    console.log(s5 instanceof Parent5);
    console.log('--log--:', s5.constructor); // Parent5

    /**
     * 组合继承的优化2
     * */
    function Parent5() {
        this.name = 'parent5';
        this.play = [1, 2, 3];
    }

    function Child5() {
        Parent5.call(this);
        this.type = 'child5';
    }

    Child5.prototype = Object.create(Parent5.prototype); // 隔离父类和子类的原型对象 通过这个属性查看.__proto__
    Child5.prototype.constructor = Child5;

    var s7 = new Child5();

    console.log(s7 instanceof Child5);
    console.log(s7 instanceof Parent5);
    console.log(s7.constructor); // Child5

</script>
</body>
</html>
